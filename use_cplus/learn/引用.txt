给变量起别名
语法：数据类型 &别名 = 原名

int a=10;
int &b = a;
a和b指向同一个内存

注意：
引用必须初始化
引用一旦初始化后就不可以更改

-------------------------------------- 本质 --------------------------------------
引用的本质在c++内部实现是一个指针常量
void func(int& ref) {  // 发现是引用，转换为  int* const ref = &a;
    ref = 100;  // ref是引用，转换为  *ref = 100;
}
int main() {
    int a = 10;

    int& ref = a;  // 自动转换为  int* const ref = &a;  指针常量是指针指向不可改，也说明为什么引用不可更改
    ref = 20;  // 内部发现ref是引用，自动帮我们转换为  *ref = 20;

    func(a);
}
c++推荐使用引用技术，因为语法方便，引用本质是指针常量，但是所有的指针操作都帮我们做了

------------------------------------------------
引用用作函数参数
------------------------------------------------
作用：函数传参时，可以利用引用技术让形参修饰实参
优点：可以简化指针修改实参
函数的形参相当于起的别名
例：

---------- 1.值传递 ----------
void swap(int a, int b){
    int temp = a;
    a = b;
    b = temp;
}

---------- 2.地址传递 ----------
void swap(int *a, int *b){
    int temp = *a;
    *a = *b;
    *b = temp;
}

---------- 3.引用传递 ---------- 可以修饰实参
void swap(int &a, int &b){
    int temp = a;
    a = b;
    b = temp;
}

------------------------------------------------
引用用作函数返回值
------------------------------------------------
注意：
不要返回局部变量引用
函数的调用可以作为左值
例：

int& test1() {
    int a = 10;
    return a;
}
int& test2() {
    static int a = 20;
    return a;
}

int main() {
    int &ref = test1();

    cout << ref << endl;  // 第一次结果正确，因为编译器做了保留
    cout << ref << endl;  // 第二次结果错误，因为a的内存已经释放

    int &res = test2();

    cout << res << endl;  // 第一次结果正确，打印20
    cout << res << endl;  // 第二次结果正确，打印20，因为static创建的a是全局区的地址

    test2() = 1000;  // 相当于 a=1000，函数返回的是a的引用

    cout << res << endl;  // 打印1000，res是a的别名
    cout << res << endl;  // 打印1000
}

------------------------------------------------
常量引用
------------------------------------------------
作用：用来修饰形参，防止误操作
加上 const 之后变为只读

int & ref = 10; // 引用必须引一块合法的内存空间
const int & ref = 10; // 加上const之后，编译器将临时分配一个空间，代码修改为：int temp = 10; const int & ref = temp;

void test(const int &ref) {
    // 此时ref为只读，不可修改
}

int main() {
    int a = 10;
    test(a)
}
